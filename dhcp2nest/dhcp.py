"""
Functions for detecting DHCP events
"""
import logging
logger = logging.getLogger(__name__)
import re
from asyncio import coroutine, Queue, async
from collections import namedtuple
from .util import follow_file


DhcpEvent = namedtuple('DhcpEvent', ['event', 'mac', 'ip', 'name', 'iface'])


_name_pattern = re.compile(r'^\((.*)\)$')


def _find_by_prior_token(tokens, keys):
    """
    If any key in keys appears in tokens, return the token following said key.
    If more than one key in keys matches, use the first matching key in keys.
    Otherwise, return None.
    """
    # Determine which key matches
    match_key = None
    for key in keys:
        if key in tokens:
            match_key = key
            break
    else:
        return None

    # Determine the index of the following token
    index = tokens.index(match_key) + 1
    if index >= len(tokens):
        return None
    return tokens[index]


@coroutine
def _find_events_task(event_queue, log_queue):
    """
    Pull log lines from log_queue continuously, detecting ISC DHCPD log
    lines, parsing them, and emitting events to the event_queue
    """
    while True:
        # Get a line and break it into its parts
        raw_line = yield from log_queue.get()
        line = raw_line.rstrip()
        parts = line.split()

        # Keep line only if it may be generated by ISC DHCPD
        try:
            index = parts.index('dhcpd:')
        except ValueError:
            continue

        logger.debug('received: %s', line)

        # Slice off leading fields
        parts = parts[(index + 1):]
        n_parts = len(parts)

        # Abort if no more fields
        if n_parts == 0:
            continue

        # Reset fields
        event = None
        mac = None
        ip = None
        name = None
        iface = None

        # Determine the event type
        event = parts[0]
        if not event.startswith('DHCP'):
            continue

        # Determine fields
        mac = _find_by_prior_token(parts, ('from', 'to'))
        ip = _find_by_prior_token(parts, ('on', 'for'))
        iface = _find_by_prior_token(parts, ('via',))

        # Look for a name
        names = [m.groups()[0] for m in
                 (_name_pattern.match(part) for part in parts)
                 if m]
        if names:
            name = names[-1]

        # Create and emit the tuple
        dhcp_event = DhcpEvent(event, mac, ip, name, iface)
        yield from event_queue.put(dhcp_event)


def find_events(log_queue, max_events=100, loop=None):
    """
    Return an asyncio.Queue that is fed DhcpEvent namedtuples extracted from
    lines sent to the log_queue asyncio.Queue
    """
    event_queue = Queue(maxsize=max_events, loop=loop)

    # Spawn a task to read data from queue
    async(_find_events_task(event_queue, log_queue), loop=loop)

    # Return the output queue
    return event_queue
